
%-----Chapter 4: Estimation-------%
\chapter{Implementations of the Kalman Filter in MATLAB}

\section{Estimation of the Robots}

As we have seen before, the motion equations of the robots are nonlinear, which makes it necessary to use an extended Kalman filter for the estimation of the robots. The function {\fontfamily{pcr}\selectfont robot\_ekf(robot\_m,robot\_e,m\_values,e\_values,d\_omega,v,P).m} is dedicated for this task. As stated in the theory above, we will need the old estimates and the measurements in order to compute new estimates. Most matrices like the covariance matrices or the Jacobian matrices are the same for all eight robots and hence have to be defined only once. The error covariance \(P\) and the estimator \(K\) on the other side have to be stored for every robot individually, therefore we will use cell arrays for this task. The initialization in MATLAB of these parameters is shown below

\lstinputlisting[firstline=18, lastline=27]{../Simulation/Merge/dummyPro_ekf.m}
\parskip 20pt

In a next step we calculate the Kalman estimate for every robot. In a former version of the function, the two cell arrays {\fontfamily{pcr}\selectfont m\_values} and {\fontfamily{pcr}\selectfont e\_values} contained a history of the last measurements and estimates of the robots. They were used to improve the performance of the extended Kalman filter. The collision detection of former versions of the simulation made it necessary for the filter algorithm to be responsive to large changes of the direction of the robots. Since the Kalman filter itself couldn't handle these rapid changes, we needed a function that indicates that the measurements are much more reliable if there is a huge difference between them and the estimates over a certain space of time. The essential functionality was  to reduce the matrix \(R\), which caused the extended Kalman filter to heaviliy trust the incoming measurements. For this task a history of former measurements and estimates was necessary. But since these problems disappeared with the introduction of collision avoidance, the used methods are obsolete. The function {\fontfamily{pcr}\selectfont i\_measurement(robot\_m,m\_values,e\_values).m} however is still needed for another reason: Measurement drops over a large time span will cause divergence between estimated values and actual values. Regaining visual information from robots will eventually lead to convergence of both values, but this usually happens way too slow. Therefore we needed a method to get the estimates quickly back on track, if there is a huge difference between them and the measurements. The following computations are done for every robot

\lstinputlisting[firstline=31, lastline=36]{../Simulation/Merge/i_measurement.m}

The current implementation uses probabilistic methods, to decide how to reduce the matrix \(R\). The key idea behind this method is, to compute how probable it is, that the measurements and estimates differ even more, than they actually do. For example: If the estimation of a variable is equal to its measurement, we have probability \(100\%\) that their difference is even bigger. In this case \(R\) is multiplied by 1; there is no need to trust the measurement more than usual because our estimation is pretty good.
Another challenge of the estimation was how to get information about the inputs of enemy robots. This task is done by {\fontfamily{pcr}\selectfont input\_approximation(robot\_m,m\_values,v).m}. The goal is to reconstruct the change of the angular position and the velocity only by looking at the measurements. Since the change of the angular position is a random process which produces statistically independent values for every timestep, a prediction of this value is impossible. The best one can do is therefore to form the difference between the robot's measured direction in time step \(k\) and \(k-1\), so we get a delay of one timestep in our calculations. The input variable will now contain some error, but this can be handled by the Kalman filter as long as the error is small enough. For the velocity on the other side we use a different method. The velocity is computed out of the position measurements, which are heavily affected by noise. Therefore the computation of the velocity in only one timestep is not very reliable. We solved this problem by using a sliding window, meaning that the velocity, we use as an input, is the mean value of velocities of several timesteps. This is a valid approach, since contrary to the change of angular position, the velocity can't change very rapidly. The corresponding code excerpt is shown below

\lstinputlisting[firstline=33, lastline=35]{../Simulation/Merge/input_approximation.m}

If there are no measurements at all, we assume maximal velocity and zero change in direction.
After facing the problems presented above, we could implement the time update and measurement update equations just as they were stated in the theory. The MATLAB-code below forms the core of the extended Kalman filter for the robots

\lstinputlisting[firstline=71, lastline=85]{../Simulation/Merge/dummyPro_ekf.m}
\parskip 20pt

The prediction of the robot's position and direction can be done for every time step, but the correction is only possible if all measurements are available. This is not the case for example if robots don't get visual information of other robots. With the if-statement we accomodate this fact. So the typical Kalman cycle is only executed if we have measurement on the positions and the direction. Otherwise we drop the measurement update, i.e. our new estimate is simply a simulation of the robot's motion with the former estimates.
\parskip 10pt


\section{Estimation of the Ball}

The estimation of the ball is done by {\fontfamily{pcr}\selectfont ball\_kf(Ball\_oe, Ball\_m, P\_oe).m}. This function has essentially the same functionality as the Kalman filter for the robots. If there are measurements of the ball's position and direction, the time update and measurement update equations are computed, otherwise only the time update equations are calculated. The only difference between the ball and the robots is, that large changes of its motion are possible. Such discrete events are handled with the if-statement shown below

\lstinputlisting[firstline=23, lastline=28]{../Simulation/Merge/ball_kf.m}

So the Kalman filter for the ball is switch triggered: If a certain threshold of acceptable error in position or direction estimation is exceeded, we reset the Kalman filter. This has the effect that the tracking of the ball is quickly reestablished after a collision with a robot or with some of the boundaries.




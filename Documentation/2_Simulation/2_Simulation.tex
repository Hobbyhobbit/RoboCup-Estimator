
%-----Chapter 2: Simulation-------%
\chapter{Simulation}

One main aspect of this group work among the design of a Kalman filter was the construction of a graphical environment for our work, so we decided to implement a simulation of a Nao soccer match in MATLAB. Therefore we created three independent modules which build the framework for the simulation. The three parts contain functions concerning the playing field, the robots and the ball respectively. Since these parts are constructed in a modular fashion, we can change one module without influencing the other two.

% Pseudocode
\begin{verbatim}
test test
\end{verbatim}

All functions mentioned above build the core of a simple random simulation of a RoboCup soccer match. The simulation is called random because the input paramters of the robots, i.e. their velocity and their change of angular direction, are chosen randomly. The script {\fontfamily{pcr}\selectfont RoboCupSim.m} is essentially a finite loop with the described functions in it and every step in the loop generates a new frame of our simulation. Most of the global variables are defined in {\fontfamily{pcr}\selectfont RoboCupSim.m} such as the dimensions of a real RoboCup playing field or all noise-relevant parameters. Also variables which cannot be initialized in a function, such as the covariance matrices for the Kalman filters which will be discussed later, are defined in this script. The length of a simulation is user configurable and is currently set to 2000 frames.


\section{Plots}

All graphical features concerning the playing field are implemented by the function {\fontfamily{pcr}\selectfont plot\_env.m}. It is subdivided in two functions, which draw the field and, as a neat add on, the scorecounter seperately. We mostly use built-in MATLAB commands for this task such as {\fontfamily{pcr}\selectfont rectangle()} or {\fontfamily{pcr}\selectfont line()}. The following short code excerpt shows for example how the center point of the playing field is drawn

\lstinputlisting[firstline=27, lastline=28]{../Simulation/Merge/plot_env.m}
\parskip 20pt

where {\fontfamily{pcr}\selectfont draw\_circle(x,y,r,color,filled)} is a custom-build function to draw marker circles of the field, but also circles representing the robots and the ball. All functions are designed for fast calculations since we want as many frames as possible if the simulation is running. Figure \ref{Playing_filed} shows the playing field after the execution of {\fontfamily{pcr}\selectfont plot\_env.m}
\parskip 10pt

\begin{figure}[htbp]
	\centering
    	\includegraphics[width=12cm]{./2_Simulation/playing_field}
  	\caption{Playing field after initialization.}
  	\label{Playing_field}
\end{figure}


\section{The Robots}

Maybe the most important part of the simulation is the adequate depiction and behaviour of all eight robots. The latter task is split in three components: In a first step the robots are initialized, after that, their new positions on the field, according to their motion equations, are computed and in the end we are adding measurement noise for our filtering task. The initialization of the robots is quite simple. The function {\fontfamily{pcr}\selectfont dummy\_init().m} just creates eight structs with the essential informations for every robot, i.e. its horizontal and vertical position, its direction and its team affiliation. Furthermore the function defines the robot's radius and its maximum possible angular change for one timestep as global variables. In a latter stage of development we dropped the simplification of a global eye and assumed that a location of a robot's position is only possible if it is in the sight of view of at least one other robot. So in the second version {\fontfamily{pcr}\selectfont robot\_init().m} of this function, we additionally defined global variables for the robot's velocity, its distance of sight as well as its angle of sight. Once initialized we use the functions {\fontfamily{pcr}\selectfont dummy\_step(Robot).m} and {\fontfamily{pcr}\selectfont robot\_step(Robot,Ball).m} respectively to compute the attributes of all robots for every timestep. The key issue of both functions however is the recalculation of the position, i.e. the motion of the robots

\lstinputlisting[firstline=20, lastline=27]{../Simulation/Merge/dummy_step.m}
\parskip 20pt

Later on the non-linearity of these equations will make it necessary that we use an extended Kalman filter instead of a simple linear one. The addition of process noise and the collision handling of robots also happen in these functions. The process noise we use for our model is always white Gaussian noise with seperate covariances for the positions and the directions. The handling of collisions, between robots and the field's border, however is different for both step-functions. In {\fontfamily{pcr}\selectfont dummy\_step(Robot).m} we used a very simple model, assuming that if two robots collide, their directions swap such that they do not run into each other

\lstinputlisting[firstline=52, lastline=53]{../Simulation/Merge/dummy_step.m}
 
This solution was not optimal for two reasons: First we had the problem that there was a bug which made it possible that two robots became wedged together and their further behaviour was messed up after they had contact. The second problem was, that our Kalman filter didn't work properly since the swapping of directions is a rapid change in states, which cannot be handled by our Kalman filter. The function {\fontfamily{pcr}\selectfont robot\_step(Robot,Ball).m} eliminates both issues because it doesn't use collision detection but collision avoidance. If the distance of two robots falls below a given radius, we assign a potential to both robots. The effect is now similar to this of a positive charge in an electrostatic field: The closer two robots are, the bigger is their mutual repulsion. As you can see below, we use the same \(r^{-2}\)-relation for the repulsing force as it is known from the analysis of electrostatic fields

\lstinputlisting[firstline=35, lastline=46]{../Simulation/Merge/robot_step.m}

The change of directions is now continuous, which makes tracking still possible for our Kalman filter. Additionally to the collision avoidance, the robots are now attracted to the ball if it near them. Up to this point we computed the behaviour of an ideal robot. Since our goal is to filter out the uncertainty of motion of the robot parameters, we artifically have to add some measurement noise which we can filter later on. The functions {\fontfamily{pcr}\selectfont dummy\_measure(Robot).m} and {\fontfamily{pcr}\selectfont robot\_measure(Robot).m} are implemented for that purpose. {\fontfamily{pcr}\selectfont dummy\_measure(Robot).m} simply adds white Gaussian noise to the position and the direction of every robot. Additionally with a certain possibillity there is no measurement at all, so the corresponding parameter is dropped. What we are assuming with this model is, that there is some global eye available which measures the position and direction of every robot with some given resolution. Since this scenario is not realistic in a RoboCup soccer match, because only the robots themselves can gain visual information, we developed the function {\fontfamily{pcr}\selectfont robot\_measure(Robot).m} to solve this problem. According to this philosophy, a measurement of a robot is only available if it stands in front of a characteristic point on the field or if it is within the distance of sight of another robot. Note that a robot only locates other robots if it is aware of its own position and that we get information from only one team, which will be the case for official RoboCup matches. If more than one measurement is available for a robot, the mean of all measurements is computed.
\parskip 10pt
After this computational part, the robots are added to the graphical environment by using the function
{\fontfamily{pcr}\selectfont plot\_robot(Robot,Ball,style).m}. It provides several features such as the coloration, the shape and the label of the robots on the field. A sample output on the graphical interface after several timesteps is shown in figure \ref{Plot_robots} below

\begin{figure}[htbp]
	\centering
    	\includegraphics[width=12cm]{./2_Simulation/plot_robots}
  	\caption{Capture of a regular simulation frame.}
  	\label{Plot_robots}
\end{figure}

Note that measurements (white crosses) are not available for most robots (blue and magenta circles).


\section{The Ball}

The treatment of the ball is quite similar to that of the robots. The ball object is also represented by a struct containing its horizontal and vertical position, its direction and the velocity. These parameters are set by executing {\fontfamily{pcr}\selectfont ball\_init().m}. This function also defines the ball's radius, its initial velocity and the friction towards the ground. The function {\fontfamily{pcr}\selectfont ball\_step(Ball,Robot).m} does, like the equivalent function for the robots, the computations of the ball's next position and direction on the field. These parameters however do not only depend on the ball's dynamics but also whether it collides with one of the robots. The following MATLAB code shows the algorithm for this collision detection

\lstinputlisting[firstline=40, lastline=51]{../Simulation/Merge/ball_step.m}
\parskip 20pt

In our simple model we assume that if the ball collides with one of the robots, it regains its initial velocity and bounces away, perpendicular to the robot's position. Since the ball too is a subject of measurement, we also needed a measurement function for this object. {\fontfamily{pcr}\selectfont ball\_measure(Ball).m} adds measurement noise or, as the case may be, drops the measurement completely. Again, a measurement is only available if it is in the sight of view of at least one blue robot that knows its own position. For more than one measurement the mean value of all measurements is taken. After all computations are done, the ball is drawn on the field, together with the robots, with the function {\fontfamily{pcr}\selectfont plot\_robot(Robot,Ball,style).m}. All features of this function like coloration and drawing of different shapes are also available for the ball.
